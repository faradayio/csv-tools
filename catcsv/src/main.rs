//! Given a list of CSV files, directories containing CSV files, compressed
//! CSV files, or some combination of the above, concatenate all the CSV files
//! together as quickly as we can.
//!
//! This replaces a 20-line shell script with two pages of Rust. But it has
//! a much nicer UI and it handles the corner cases better.

// `error_chain!` can recurse deeply
#![recursion_limit = "1024"]
// Enable clippy if we were asked to do so.
#![cfg_attr(feature = "clippy", feature(plugin))]
#![cfg_attr(feature = "clippy", plugin(clippy))]

use csv;

use env_logger;
#[macro_use]
extern crate error_chain;
#[macro_use]
extern crate log;

use snap;
use walkdir;

use csv::ByteString;
use docopt::Docopt;
use std::borrow::Cow;
use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader, BufWriter};
use std::process;
use walkdir::WalkDir;

use crate::errors::*;

/// A module to hold `Error`, etc., types generated by `error-chain`.
mod errors {
    use csv;
    use std::io;
    use std::path::PathBuf;
    use walkdir;

    error_chain! {
        foreign_links {
            Csv(csv::Error);
            Io(io::Error);
            WalkDir(walkdir::Error);
        }

        errors {
            ReadFile(path: PathBuf) {
                description("error reading file")
                display("error reading '{}", path.display())
            }
        }
    }
}

// Ask `error-chain` to build us a `main` function that prints errors, and
// delegate the real work to `run`.
quick_main!(run);

const USAGE: &'static str = "
catcsv - Combine many CSV files into one

Usage:
  catcsv <input-file-or-dir>...
  catcsv (--help | --version)

Options:
  --help        Show this screen.
  --version     Show version.

Input files must have the extension *.csv or *.csv.sz.  The latter are assumed
to be in Google's \"snappy framed\" format: https://github.com/google/snappy

If passed a directory, this will recurse over all files in that directory.
";

/// Our command-line arguments.
#[derive(Debug, RustcDecodable)]
struct Args {
    /// Should we show the version of the program and exit?
    flag_version: bool,
    /// A list of files and directories to output.
    arg_input_file_or_dir: Vec<String>,
}

/// Our real `main` function that parses arguments and figures out what to do.
fn run() -> Result<()> {
    env_logger::init().expect("could not initialize log subsystem");

    let args: Args = Docopt::new(USAGE)
        .and_then(|dopt| dopt.decode())
        .unwrap_or_else(|e| e.exit());
    debug!("{:?}", args);

    // Report our version.
    if args.flag_version {
        println!("catcsv {}", env!("CARGO_PKG_VERSION"));
        process::exit(0);
    }

    // Lock and buffer stdout for maximum performance.
    let stdout = io::stdout();
    let stdout_locked = stdout.lock();
    let mut out = BufWriter::new(stdout_locked);

    // Iterate over our arguments.  We do this without using recursion, mostly
    // to see how that looks in Rust.
    let mut first_headers: Option<Vec<ByteString>> = None;
    let mut files_processed: u64 = 0;
    for input in &args.arg_input_file_or_dir {
        for entry in WalkDir::new(input).follow_links(true) {
            let entry = entry?;

            // We want to skip directories, but process files _and_ pipes.
            // Pipes are critical when working with Pachyderm, which uses
            // named pipes for inputs.
            if !entry.file_type().is_dir() {
                debug!("Found file: {}", entry.path().display());
                let filename: Cow<'_, str> = entry.file_name().to_string_lossy();
                let path = entry.path();
                let mkerr = || ErrorKind::ReadFile(path.to_owned());

                // Check the filename to see if we can handle this file type.
                if filename.ends_with(".csv") {
                    debug!("Processing as *.csv");
                    let mut file = File::open(path).chain_err(&mkerr)?;
                    output_csv(&mut file, &mut first_headers, &mut out)
                        .chain_err(&mkerr)?;
                } else if filename.ends_with(".csv.sz") {
                    debug!("Processing as *.csv.sz");
                    let file = File::open(path).chain_err(&mkerr)?;
                    let mut decompressed = snap::Reader::new(file);
                    output_csv(&mut decompressed, &mut first_headers, &mut out)
                        .chain_err(&mkerr)?;
                } else {
                    let msg =
                        format!("{} does not appear to be a CSV file", path.display());
                    return Err(msg.into());
                }

                // Keep track of how many files we processed.
                files_processed += 1;
            }
        }
    }

    // If we don't have any files, we won't produce any headers, so
    // fail with an error.
    if files_processed == 0 {
        return Err("No input CSV files found".into());
    }

    Ok(())
}

/// Output the specified CSV data to stand
fn output_csv(
    file: &mut dyn Read,
    first_headers: &mut Option<Vec<ByteString>>,
    output: &mut dyn Write,
) -> Result<()> {
    // Force buffered input for a big performance boost and so we can
    // get the first line.
    let mut input = BufReader::new(file);

    // Get the first line of headers, and parse it as CSV.
    //
    // NOTE: This will fail if there are escaped newlines in the header line.
    let mut first_line = String::new();
    input.read_line(&mut first_line)?;
    let mut rdr = csv::Reader::from_string(first_line.clone());

    // Get our header line only.
    let headers = rdr.byte_headers()?;

    // If this is the first set of headers we've found, save them.  If not,
    // make sure that the headers match between files.
    if let Some(ref first_headers) = *first_headers {
        if &headers != first_headers {
            return Err("CSV headers are different from the first file's".into());
        }
    } else {
        debug!("Using headers: {}", first_line);
        *first_headers = Some(headers);
        output.write_all(first_line.as_bytes())?;
    }

    // Do the fastest pass-through copy the standard library can manage.
    io::copy(&mut input, output)?;

    Ok(())
}
